###################
Working with Spyder
###################

In this section, you will learn about Spyder's more advanced functionality, and explore most of the panes.



=====================
Beyond the main panes
=====================

Explore how to take advantage of Spyderâ€™s functionality beyond just the four core panes.

* View, manage and save figures with the Plots pane
* Browse, interact with and open external programs in the in the Files pane
* Quickly navigate within and between files with the Outline pane
* Search for text or regular expressions across your entire project with the Find pane
* Discover and explore structured documentation in the Online Help pane

.. youtube:: NOu9JTkUuDg
   :height: 360
   :width: 640
   :align: left

.. rst-class:: dropdown-videos

.. dropdown:: Transcript
   :animate: fade-in

   .. div:: scroll

      Hello everyone! I'm Juanita, and I am going to show you how to use some of the remaining panes available in Spyder beyond just the four primary ones.

      Let's start with the Plots pane, which is open by default when launching Spyder. To see how it works, let's open a file that will generate a couple plots from Matplotlib's documentation. You can view the generated plots in the Plots pane and browse between them using the arrows, or simply clicking them in the sidebar.

      If you open the pane's options menu, you will see that Fit Plots to Window is enabled by default. Disabling it will allow you to zoom the plots in or out. You can also see that Mute inline plotting is enabled, which prevents the same figures from also appearing in the IPython Console. Note that every time that the code is run, new copies of the plots are generated in the pane, but you can remove any you don't want to keep around with the X button in the pane toolbar. Additionally, the pane automatically updates to show the plots generated by each console as you switch between them.

      To use a plot in another document, click the Copy to Clipboard button and paste it wherever you want, such as a word processor. Additionally, you can save a plot as a PNG by clicking the save icon.

      The Files pane, also open by default, lets you browse the contents of the directories on your computer, open them in the Editor, and perform a variety of other file operations. You can show or hide the size, kind and date of the files in the pane's options menu. As you change the top-level folder you're viewing in the pane, Spyder's working directory shown in the top right of the main toolbar will update, which will also be synchronized with the currently active console. Double-clicking a text file will open it in the Editor, and copying one or more files will allow you to paste them as automatically-formatted absolute or relative paths. Right-clicking any item will offer an array of additional options for interacting with it.

      You can also open a file in the system default external application, or set up a custom file association in the File Associations tab of the Files preferences pane. For example, we can add the ``.csv`` extension and associate it with LibreOffice Calc under associated applications. Now every time you click a file with this extension, it opens externally with this program.

      Now, let's see how to use the Outline pane to navigate within a file. First, we have to open the pane under Panes in the View menu, since it isn't visible by default. As you can see, it shows you all the classes, methods and functions that are currently defined, and allows you to move between them with just a click. For a very large file like this one, it is very useful to switch between classes easily instead of scrolling through the four-thousand-plus lines of code. You can also browse the methods of a class by expanding it using the arrows, or the buttons in the Outline pane's toolbar. The Outline continuously updates to highlight the function, method or class corresponding to the cursor position in your code, so you can easily keep track of what object you are working on. Finally, by going to the pane options menu and activating Show all files, you can easily switch between the scripts and modules you have open, which is particularly important for navigating larger projects.

      The Files pane is another useful tool for particularly larger projects. Like the Outline pane, it can be opened under Panes in the View menu. This allows you to view and navigate through all occurrences of text or regular expressions in any file in the working directory, project or another custom directory. We see, for example, in the ``mainwindow.py`` file we import the ``is_dark_font_color`` function. If we want to quickly find the file where it was defined, we can write this string in the search bar. With this search, we get 7 matches from 3 different files. When we click on any of these matches, the file is opened automatically in the Editor, right where this string appears.

      Finally, we'll learn how to browse documentation using the Online Help pane. Once you open it, again under Panes in the View menu, you will see an index of modules from which documentation is available, including both those in the Python standard library and any third-party packages that may be installed in Spyder's environment. For example, we can find help for Numpy, Pandas and Matplotlib, which are all installed if you've downloaded Spyder with Anaconda. You can browse the contents in the built-in web browser provided by the pane, and click the hyperlinks within to navigate to different pages. You can also enter the name of the item you'd like documentation on in the Get field or in the space over the pane's toolbar, to load its information directly. If you're not sure of the object's name, use the Search field to view a list of results applicable to any keyword.

      Now that you're familiar with a wider array of Spyder's panes and features, you can accomplish a variety of common programming tasks with ease. Stay tuned for our our next videos to further add to your scientific toolbox, and as always, Happy Spydering!



===========================
Improving your code quality
===========================

Learn how to improve the quality of your programs using code analysis.

* Open and use Code Analysis to evaluate the quality and style of Python files
* Run analysis on a file in the Editor or anywhere on your computer
* Determine what an error, warning or message means and how to fix it
* Turn off messages on a line, in a file or globally

.. youtube:: JnljnAjdO_w
   :height: 360
   :width: 640
   :align: left

.. rst-class:: dropdown-videos

.. dropdown:: Transcript
   :animate: fade-in

   .. div:: scroll

      Hello everyone! I'm Juanita, and in this video we will learn how to improve your code quality using the Code Analysis pane. To display it, we can click its name under Panes in the View menu.

      This pane detects style issues, bad practices, potential bugs and other quality problems in your code, without having to execute it. There are three ways of running code analysis:

      * To analyze a file that is open in the Editor, we can press the configurable shortcut, :kbd:`F8` by default, or select Source --> Run code analysis from the menu bar.

      * We can also select a file to analyze by browsing for it using the file button next to the path box. This will start the analysis automatically.

      * The third way is to manually enter the path of a file we'd like to check in the path entry box in the pane's toolbar, and click the Analyze button in the pane.

      Based on these results, the code analysis shows an overall score of 4.34/10, which allows us to track improvements in our code quality. We can also expand or collapse one or all the sections in the pane to be able to see the Pylint errors, warnings and messages identifying the issues with our code.

      For example, the results tell us that there is a warning on line 20. To go directly to this line in the Editor, just click the message. Here, the code analysis says there is a ``bad-whitespace`` issue. To understand what this means, open the Pylint documentation. On the `Pylint docs page`_ , click on Pylint features and search for the code of the message.

      .. _Pylint docs page: https://pylint.pycqa.org/en/stable/index.html

      We can see that the docs say that we used the wrong number of spaces around an operator.

      .. code-block::

         bad-whitespace [C0326]:

         %s space %s %s %s Used when a wrong number of spaces is used around an operator, bracket or block opener.

      We can fix the error by adding one space before and after the operator in this variable assignment. If we run the analysis again, we can see the error isn't shown any more on this line.

      We can click the dropdown arrow in the filename field to view the list of previous analyses. Clicking one of them will show us the results.

      Sometimes, it is useful to turn certain messages off. We can do that in three different ways.

      We might want to silence warnings on only one line; for example, this "unused" import that is still necessary for the code execution. For this, type ``# pylint: disable=unused-import`` as a comment at the end of the line. Running the analysis again will show us that the error is no longer visible.

      If we want to silence a message in the whole file, we can do it by writing the disable command at the beginning of the file. For example, we can disable the ``invalid-name`` warning that appears several times in this file. If we run the analysis again, all of these warnings are gone.

      Finally, we can suppress specific messages for all files by editing the ``.pylintrc`` configuration file in your user folder. If it doesn't exist, we can generate it by opening our terminal, or the Anaconda Prompt if you're using Windows, and running ``pylint --generate-rc > .pylintrc`` in our user directory.

      Now, we can go to the ``MESSAGE CONTROL`` section in this file and add the corresponding Pylint message name, for example ``no-name-in-module``. If we run the analysis one more time, we see that the ``no-name-in-module`` warnings don't appear anymore.

      We can see that the score of our file increased to 7.63/10, a big improvement over the previous 4.34.

      Now that we've learned how to improve the quality of our code, you are ready to write cleaner and more correct programs using Spyder. Stay tuned for our next videos and as always, Happy Spydering!



====================
Optimizing your code
====================

Learn how to optimize your code using the Profiler.

* Use the Profiler to find bottlenecks in your programs
* Run profiling on a file in the Editor or elsewhere on your machine
* Interpret the results to evaluate function and method performance
* Use the information to speed up the run time of your code

.. youtube:: 4hcXa8aGu_c
   :height: 360
   :width: 640
   :align: left

.. rst-class:: dropdown-videos

.. dropdown:: Transcript
   :animate: fade-in

   .. div:: scroll

       Hello everyone! I'm Juanita, and in this video we will learn how to optimize your code using the profiler. To display it, click its name under Panes in the View menu.

      The Profiler will determine the run time and number of calls for every function and method used in a file. There are three ways of profiling a file:

      * We can browse for a file using the open button to the right of the Profiler's path box, which will run profiling over it automatically.

      * We can also manually enter the path in the pane's path box, and then run the analysis on the file by pressing the Profile button.

      * If we want to run the profiler for the file that is currently open in the Editor, we can click Run --> Profile... in the menu bar, or use the configurable shortcut :kbd:`F10`.

      We see that the results in the pane show us the different functions and methods in our file, with each sub-function listed hierarchically under the item that called them. The columns show the total time taken by each function and everything it called, while the local time includes only the time spent in that particular function.

      For example, the function ``values`` in this file calls a function ``internal_values`` values took a total of 482 us to run, with 338 us of that spent executing internal_values inside of it. Therefore, the total time for values is 482 us, but its local time is only 144 us as the rest was spent inside ``internal_values``.

      The Calls column displays the total number of times that function was called at that level. Finally, the numbers in the Diff columns for each of the three appear if a comparison is loaded, and indicate the change in runtime between the two measurements.

      By double-clicking an item in the Profiler, we will be taken to the file and line in the Editor where it was called. If this function was not called in one of your open scripts, clicking it will open the file that contains it. We can click the down arrow button in the filename field to recall paths of previously profiled files.

      Now that we know how to interpret the results of our profiling, let's optimize our code by finding the functions that take the longest time and making them faster. In this case, ``to_datetime`` takes 39 seconds to run. The reason for this is Pandas has to parse the non-standard timestamp format and is not told to try to use a faster parser than the default.

      We can reduce the time this function takes and compare it with the one before. For this, first we have to save the data as a ``.Result`` file with the save button in the pane. Now we have to figure out how to optimize the function, so let's search for it. We see that we can speed up this function by `manually specifying a datetime format`_. So, we add the appropriate argument, ``format="%Y-%m-%d %H:%M:%S.%f %z"``, to our function call.

      .. _manually specifying a datetime format: https://stackoverflow.com/questions/32034689/why-is-pandas-to-datetime-slow-for-non-standard-time-format-such-as-2014-12-31

      Now, we run the profiling again to see how our script's performance has improved. If we want to see how much we lowered the time, we can load our previous result and take a look at the diff columns. Notice the difference is green because the time was reduced by three times, taking only 13 seconds instead of 39. Our code is now 26 seconds faster!

      Now that you've learned how to analyze the execution time of your code, you are ready to write more efficient programs with Spyder's help. Stay tuned for our next videos and as always, Happy Spydering!
